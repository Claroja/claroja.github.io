const e=JSON.parse('{"key":"v-7400322e","path":"/8%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B/2_1flink/window/window.html","title":"window","lang":"zh-CN","frontmatter":{"description":"window 在流处理中，我们往往需要面对的是连续不断、无休无止的无界流，不可能等到所有所有数据都到齐了才开始处理。所以聚合计算其实只能针对当前已有的数据，之后再有数据到来，就需要继续叠加、再次输出结果。这样似乎很“实时”，但现实中大量数据一般会同时到来，需要并行处理，这样频繁地更新结果就会给系统带来很大负担了。 更加高效的做法是，把无界流进行切分，每一段数据分别进行聚合，结果只输出一次。这就相当于将无界流的聚合转化为了有界数据集的聚合，这就是所谓的“窗口”（Window）聚合操作。窗口聚合其实是对实时性和处理效率的一个权衡。在实际应用中，我们往往更关心一段时间内数据的统计结果，比如在过去的 1 分钟内有多少用户点击了网页。在这种情况下，我们就可以定义一个窗口，收集最近一分钟内的所有用户点击数据，然后进行聚合统计，最终输出一个结果就可以了。","head":[["meta",{"property":"og:url","content":"https://claroja.github.io/8%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B/2_1flink/window/window.html"}],["meta",{"property":"og:site_name","content":"Claroja"}],["meta",{"property":"og:title","content":"window"}],["meta",{"property":"og:description","content":"window 在流处理中，我们往往需要面对的是连续不断、无休无止的无界流，不可能等到所有所有数据都到齐了才开始处理。所以聚合计算其实只能针对当前已有的数据，之后再有数据到来，就需要继续叠加、再次输出结果。这样似乎很“实时”，但现实中大量数据一般会同时到来，需要并行处理，这样频繁地更新结果就会给系统带来很大负担了。 更加高效的做法是，把无界流进行切分，每一段数据分别进行聚合，结果只输出一次。这就相当于将无界流的聚合转化为了有界数据集的聚合，这就是所谓的“窗口”（Window）聚合操作。窗口聚合其实是对实时性和处理效率的一个权衡。在实际应用中，我们往往更关心一段时间内数据的统计结果，比如在过去的 1 分钟内有多少用户点击了网页。在这种情况下，我们就可以定义一个窗口，收集最近一分钟内的所有用户点击数据，然后进行聚合统计，最终输出一个结果就可以了。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://claroja.github.io/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-21T12:59:55.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"window"}],["meta",{"property":"article:author","content":"claroja"}],["meta",{"property":"article:modified_time","content":"2025-02-21T12:59:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"window\\",\\"image\\":[\\"https://claroja.github.io/\\"],\\"dateModified\\":\\"2025-02-21T12:59:55.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"claroja\\",\\"url\\":\\"https://claroja.github.io\\"}]}"]]},"headers":[{"level":2,"title":"concept","slug":"concept","link":"#concept","children":[]},{"level":2,"title":"窗口的分类","slug":"窗口的分类","link":"#窗口的分类","children":[{"level":3,"title":"时间窗口","slug":"时间窗口","link":"#时间窗口","children":[]},{"level":3,"title":"计数窗口","slug":"计数窗口","link":"#计数窗口","children":[]}]},{"level":2,"title":"窗口API","slug":"窗口api","link":"#窗口api","children":[{"level":3,"title":"按键分区窗口（Keyed Windows）","slug":"按键分区窗口-keyed-windows","link":"#按键分区窗口-keyed-windows","children":[]},{"level":3,"title":"非按键分区（Non-Keyed Windows）","slug":"非按键分区-non-keyed-windows","link":"#非按键分区-non-keyed-windows","children":[]}]},{"level":2,"title":"Window Assigners","slug":"window-assigners","link":"#window-assigners","children":[{"level":3,"title":"Tumbling Windows","slug":"tumbling-windows","link":"#tumbling-windows","children":[]},{"level":3,"title":"Sliding Windows","slug":"sliding-windows","link":"#sliding-windows","children":[]},{"level":3,"title":"Session Windows","slug":"session-windows","link":"#session-windows","children":[]}]},{"level":2,"title":"window function","slug":"window-function","link":"#window-function","children":[{"level":3,"title":"ReduceFunction","slug":"reducefunction","link":"#reducefunction","children":[]},{"level":3,"title":"AggregateFunction","slug":"aggregatefunction","link":"#aggregatefunction","children":[]},{"level":3,"title":"ProcessWindowFunction","slug":"processwindowfunction","link":"#processwindowfunction","children":[]}]},{"level":2,"title":"其他API","slug":"其他api","link":"#其他api","children":[{"level":3,"title":"trigger(触发器)","slug":"trigger-触发器","link":"#trigger-触发器","children":[]},{"level":3,"title":"Evictor(移除器)","slug":"evictor-移除器","link":"#evictor-移除器","children":[]},{"level":3,"title":"Allowed Lateness","slug":"allowed-lateness","link":"#allowed-lateness","children":[]},{"level":3,"title":"side output","slug":"side-output","link":"#side-output","children":[]}]},{"level":2,"title":"窗口声明周期","slug":"窗口声明周期","link":"#窗口声明周期","children":[{"level":3,"title":"窗口的创建","slug":"窗口的创建","link":"#窗口的创建","children":[]},{"level":3,"title":"窗口计算的触发","slug":"窗口计算的触发","link":"#窗口计算的触发","children":[]},{"level":3,"title":"窗口的销毁","slug":"窗口的销毁","link":"#窗口的销毁","children":[]}]}],"git":{"createdTime":1740142795000,"updatedTime":1740142795000,"contributors":[{"name":"Claroja","email":"63183535@qq.com","commits":1}]},"readingTime":{"minutes":13.7,"words":4110},"filePathRelative":"8数据工程/2_1flink/window/window.md","localizedDate":"2025年2月21日","excerpt":"<h1> window</h1>\\n<p>在流处理中，我们往往需要面对的是连续不断、无休无止的无界流，不可能等到所有所有数据都到齐了才开始处理。所以聚合计算其实只能针对当前已有的数据，之后再有数据到来，就需要继续叠加、再次输出结果。这样似乎很“实时”，但现实中大量数据一般会同时到来，需要并行处理，这样频繁地更新结果就会给系统带来很大负担了。</p>\\n<p>更加高效的做法是，把无界流进行切分，每一段数据分别进行聚合，结果只输出一次。这就相当于将无界流的聚合转化为了有界数据集的聚合，这就是所谓的“窗口”（Window）聚合操作。窗口聚合其实是对实时性和处理效率的一个权衡。在实际应用中，我们往往更关心一段时间内数据的统计结果，比如在过去的 1 分钟内有多少用户点击了网页。在这种情况下，我们就可以定义一个窗口，收集最近一分钟内的所有用户点击数据，然后进行聚合统计，最终输出一个结果就可以了。</p>","copyright":{"author":"王新宇"},"autoDesc":true}');export{e as data};
