const e=JSON.parse('{"key":"v-e3210138","path":"/4%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2c%E8%AF%AD%E8%A8%80/7IO/2_5buffer.html","title":"setbuf","lang":"zh-CN","frontmatter":{"description":"setbuf void setbuf ( FILE * stream, char * buffer ); Set stream buffer 设置文件描述符的缓冲区大小 stream buffer是一个 block of data,在i/o操作和 physical file(文件) 之间 output buffers,写出:数据会放在buffer区,直到填满,然后会flushed(发送给 物理文件并清空buffer区) input buffers,也是如此 Stream buffers can be explicitly flushed by calling fflush, fclose and freopen或者程序terminates normally(正常终止)会自动调用fllush 所有打开的文件都默认带有buffer stdin and stdout are fully buffered by default if they are known to not refer to an interactive . Otherwise, they may either be line buffered or unbuffered by default 通过setvbuf 改变缓冲方式","head":[["meta",{"property":"og:url","content":"https://claroja.github.io/4%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/2c%E8%AF%AD%E8%A8%80/7IO/2_5buffer.html"}],["meta",{"property":"og:site_name","content":"Claroja"}],["meta",{"property":"og:title","content":"setbuf"}],["meta",{"property":"og:description","content":"setbuf void setbuf ( FILE * stream, char * buffer ); Set stream buffer 设置文件描述符的缓冲区大小 stream buffer是一个 block of data,在i/o操作和 physical file(文件) 之间 output buffers,写出:数据会放在buffer区,直到填满,然后会flushed(发送给 物理文件并清空buffer区) input buffers,也是如此 Stream buffers can be explicitly flushed by calling fflush, fclose and freopen或者程序terminates normally(正常终止)会自动调用fllush 所有打开的文件都默认带有buffer stdin and stdout are fully buffered by default if they are known to not refer to an interactive . Otherwise, they may either be line buffered or unbuffered by default 通过setvbuf 改变缓冲方式"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-24T12:46:58.000Z"}],["meta",{"property":"article:author","content":"claroja"}],["meta",{"property":"article:modified_time","content":"2025-02-24T12:46:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"setbuf\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-24T12:46:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"claroja\\",\\"url\\":\\"https://claroja.github.io\\"}]}"]]},"headers":[],"git":{"createdTime":1740401218000,"updatedTime":1740401218000,"contributors":[{"name":"Claroja","email":"63183535@qq.com","commits":1}]},"readingTime":{"minutes":1.5,"words":451},"filePathRelative":"4编程语言/2c语言/7IO/2_5buffer.md","localizedDate":"2025年2月24日","excerpt":"<h1> setbuf</h1>\\n<p><code>void setbuf ( FILE * stream, char * buffer );</code>  Set stream buffer</p>\\n<ol>\\n<li>设置文件描述符的缓冲区大小</li>\\n<li>stream buffer是一个 block of data,在i/o操作和 physical file(文件) 之间</li>\\n<li>output buffers,写出:数据会放在buffer区,直到填满,然后会flushed(发送给 物理文件并清空buffer区)</li>\\n<li>input buffers,也是如此</li>\\n<li>Stream buffers can be explicitly flushed by calling <code>fflush</code>, <code>fclose</code> and <code>freopen</code>或者程序terminates normally(正常终止)会自动调用<code>fllush</code></li>\\n<li>所有打开的文件都默认带有<code>buffer</code></li>\\n<li>stdin and stdout are fully buffered by default  if they are known to not refer to an interactive . Otherwise, they may either be line buffered or unbuffered by default</li>\\n<li>通过setvbuf 改变缓冲方式</li>\\n</ol>","copyright":{"author":"王新宇"},"autoDesc":true}');export{e as data};
