const t=JSON.parse('{"key":"v-600da8a2","path":"/2%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/4java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/JavaUtilConcurrent.html","title":"dataframe_sql","lang":"zh-CN","frontmatter":{"description":"dataframe_sql 线程安全类 过时的线程安全集合(用synchronized修饰, 效率低): Hashtable(map实现), Vector(list实现) 使用Collections装饰的线程安全集合(装饰器模式, 只是拿来做了封装): Collections.synchronizedMap, Collections.synchronizedSet等 java.util.concurrent: Blocking 大部分实现基于锁，并提供用来阻塞的方法, 使用ReentrantLock实现 CopyOnWrite 使用深拷贝模式, 避免不安全, 适用于读多写少的 Concurrent cas做优化, 性能比较多, 做推荐","head":[["meta",{"property":"og:url","content":"https://claroja.github.io/2%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/4java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/JavaUtilConcurrent.html"}],["meta",{"property":"og:site_name","content":"Claroja"}],["meta",{"property":"og:title","content":"dataframe_sql"}],["meta",{"property":"og:description","content":"dataframe_sql 线程安全类 过时的线程安全集合(用synchronized修饰, 效率低): Hashtable(map实现), Vector(list实现) 使用Collections装饰的线程安全集合(装饰器模式, 只是拿来做了封装): Collections.synchronizedMap, Collections.synchronizedSet等 java.util.concurrent: Blocking 大部分实现基于锁，并提供用来阻塞的方法, 使用ReentrantLock实现 CopyOnWrite 使用深拷贝模式, 避免不安全, 适用于读多写少的 Concurrent cas做优化, 性能比较多, 做推荐"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-21T12:59:55.000Z"}],["meta",{"property":"article:author","content":"claroja"}],["meta",{"property":"article:modified_time","content":"2025-02-21T12:59:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"dataframe_sql\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-21T12:59:55.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"claroja\\",\\"url\\":\\"https://claroja.github.io\\"}]}"]]},"headers":[{"level":2,"title":"线程安全类","slug":"线程安全类","link":"#线程安全类","children":[]},{"level":2,"title":"原理","slug":"原理","link":"#原理","children":[]}],"git":{"createdTime":1740142795000,"updatedTime":1740142795000,"contributors":[{"name":"Claroja","email":"63183535@qq.com","commits":1}]},"readingTime":{"minutes":1.9,"words":569},"filePathRelative":"2编程语言/4java/线程安全/JavaUtilConcurrent.md","localizedDate":"2025年2月21日","excerpt":"<h1> dataframe_sql</h1>\\n<h2> 线程安全类</h2>\\n<ul>\\n<li>过时的线程安全集合(用synchronized修饰, 效率低): Hashtable(map实现), Vector(list实现)</li>\\n<li>使用Collections装饰的线程安全集合(装饰器模式, 只是拿来做了封装): Collections.synchronizedMap, Collections.synchronizedSet等</li>\\n<li>java.util.concurrent:\\n<ul>\\n<li>Blocking 大部分实现基于锁，并提供用来阻塞的方法, 使用ReentrantLock实现</li>\\n<li>CopyOnWrite 使用深拷贝模式, 避免不安全, 适用于读多写少的</li>\\n<li>Concurrent cas做优化, 性能比较多, 做推荐</li>\\n</ul>\\n</li>\\n</ul>","copyright":{"author":"王新宇"},"autoDesc":true}');export{t as data};
