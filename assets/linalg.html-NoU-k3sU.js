import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as e,e as r}from"./app-YE2Hltoy.js";const n={},d=r(`<h1 id="linalg" tabindex="-1"><a class="header-anchor" href="#linalg" aria-hidden="true">#</a> linalg</h1><h2 id="向量的长度" tabindex="-1"><a class="header-anchor" href="#向量的长度" aria-hidden="true">#</a> 向量的长度</h2><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>norm<span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment"># 第二范数</span>
np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>norm<span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token builtin">ord</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 第一范数</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="api" tabindex="-1"><a class="header-anchor" href="#api" aria-hidden="true">#</a> API</h2><h2 id="矩阵与向量乘积" tabindex="-1"><a class="header-anchor" href="#矩阵与向量乘积" aria-hidden="true">#</a> 矩阵与向量乘积</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>dot(a, b[, out])</td><td>Dot product of two arrays.</td></tr><tr><td>linalg.multi_dot(arrays)</td><td>Compute the dot product of two or more arrays in a single function call, while automatically selecting the fastest evaluation order.</td></tr><tr><td>vdot(a, b)</td><td>Return the dot product of two vectors.</td></tr><tr><td>inner(a, b)</td><td>Inner product of two arrays.</td></tr><tr><td>outer(a, b[, out])</td><td>Compute the outer product of two vectors.</td></tr><tr><td>matmul(a, b[, out])</td><td>Matrix product of two arrays.</td></tr><tr><td>tensordot(a, b[, axes])</td><td>Compute tensor dot product along specified axes for arrays &gt;= 1-D.</td></tr><tr><td>einsum(subscripts, *operands[, out, dtype, …])</td><td>Evaluates the Einstein summation convention on the operands.</td></tr><tr><td>einsum_path(subscripts, *operands[, optimize])</td><td>Evaluates the lowest cost contraction order for an einsum expression by considering the creation of intermediate arrays.</td></tr><tr><td>linalg.matrix_power(M, n)</td><td>Raise a square matrix to the (integer) power n.</td></tr><tr><td>kron(a, b)</td><td>Kronecker product of two arrays.</td></tr></tbody></table><h2 id="分解" tabindex="-1"><a class="header-anchor" href="#分解" aria-hidden="true">#</a> 分解</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>linalg.cholesky(a)</td><td>Cholesky decomposition.</td></tr><tr><td>linalg.qr(a[, mode])</td><td>Compute the qr factorization of a matrix.</td></tr><tr><td>linalg.svd(a[, full_matrices, compute_uv])</td><td>Singular Value Decomposition.</td></tr></tbody></table><h2 id="特征值特征向量" tabindex="-1"><a class="header-anchor" href="#特征值特征向量" aria-hidden="true">#</a> 特征值特征向量</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>linalg.eig(a)</td><td>Compute the eigenvalues and right eigenvectors of a square array.</td></tr><tr><td>linalg.eigh(a[, UPLO])</td><td>Return the eigenvalues and eigenvectors of a Hermitian or symmetric matrix.</td></tr><tr><td>linalg.eigvals(a)</td><td>Compute the eigenvalues of a general matrix.</td></tr><tr><td>linalg.eigvalsh(a[, UPLO])</td><td>Compute the eigenvalues of a Hermitian or real symmetric matrix.</td></tr></tbody></table><h2 id="norms-and-other-numbers" tabindex="-1"><a class="header-anchor" href="#norms-and-other-numbers" aria-hidden="true">#</a> Norms and other numbers</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>linalg.norm(x[, ord, axis, keepdims])</td><td>求范数， 默认是二范数</td></tr><tr><td>linalg.cond(x[, p])</td><td>Compute the condition number of a matrix.</td></tr><tr><td>linalg.det(a)</td><td>Compute the determinant of an array.</td></tr><tr><td>linalg.matrix_rank(M[, tol, hermitian])</td><td>Return matrix rank of array using SVD method</td></tr><tr><td>linalg.slogdet(a)</td><td>Compute the sign and (natural) logarithm of the determinant of an array.</td></tr><tr><td>trace(a[, offset, axis1, axis2, dtype, out])</td><td>Return the sum along diagonals of the array.</td></tr></tbody></table><h2 id="solving-equations-and-inverting-matrices" tabindex="-1"><a class="header-anchor" href="#solving-equations-and-inverting-matrices" aria-hidden="true">#</a> Solving equations and inverting matrices</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>linalg.solve(a, b)</td><td>Solve a linear matrix equation, or system of linear scalar equations.</td></tr><tr><td>linalg.tensorsolve(a, b[, axes])</td><td>Solve the tensor equation a x = b for x.</td></tr><tr><td>linalg.lstsq(a, b[, rcond])</td><td>Return the least-squares solution to a linear matrix equation.</td></tr><tr><td>linalg.inv(a)</td><td>Compute the (multiplicative) inverse of a matrix.</td></tr><tr><td>linalg.pinv(a[, rcond])</td><td>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</td></tr><tr><td>linalg.tensorinv(a[, ind])</td><td>Compute the ‘inverse’ of an N-dimensional array.</td></tr></tbody></table><h2 id="exceptions" tabindex="-1"><a class="header-anchor" href="#exceptions" aria-hidden="true">#</a> Exceptions</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>linalg.LinAlgError</td><td>Generic Python-exception-derived object raised by linalg functions.</td></tr></tbody></table><p>参考: https://docs.scipy.org/doc/numpy/reference/routines.linalg.html</p>`,17),o=[d];function i(s,l){return a(),e("div",null,o)}const u=t(n,[["render",i],["__file","linalg.html.vue"]]);export{u as default};
