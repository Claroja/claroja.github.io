const t=JSON.parse('{"key":"v-780c38e6","path":"/4%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/3python/9%E8%BF%9B%E7%A8%8B/process.html","title":"process","lang":"zh-CN","frontmatter":{"description":"process 进程是资源分配的最⼩单位 进程间不能共享全局变量, 每个进程都会复制一份主进程的变量到自己的空间 构造方法 class multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None) multiprocessing.Process 和 threading.Thread 有相同的设计. 参数 描述 run() 不直接操作, 只重写 start() 启动进程 join([timeout]) 阻塞主进程(调用进程), 等待被调用了join()的process执行玩完毕 name 进程名称 is_alive() 是否存活 daemon 在start()方法之前设置 pid 进程的id, 在开始前为None exitcode 进程退出时的code authkey sentinel terminate() 使用SIGTERM结束进程, 其子进程不会结束, 而会成为orphaned kill() 使用SIGKILL结束进程 close() 关闭进程,并释放所有资源","head":[["meta",{"property":"og:url","content":"https://claroja.github.io/4%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/3python/9%E8%BF%9B%E7%A8%8B/process.html"}],["meta",{"property":"og:site_name","content":"Claroja"}],["meta",{"property":"og:title","content":"process"}],["meta",{"property":"og:description","content":"process 进程是资源分配的最⼩单位 进程间不能共享全局变量, 每个进程都会复制一份主进程的变量到自己的空间 构造方法 class multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None) multiprocessing.Process 和 threading.Thread 有相同的设计. 参数 描述 run() 不直接操作, 只重写 start() 启动进程 join([timeout]) 阻塞主进程(调用进程), 等待被调用了join()的process执行玩完毕 name 进程名称 is_alive() 是否存活 daemon 在start()方法之前设置 pid 进程的id, 在开始前为None exitcode 进程退出时的code authkey sentinel terminate() 使用SIGTERM结束进程, 其子进程不会结束, 而会成为orphaned kill() 使用SIGKILL结束进程 close() 关闭进程,并释放所有资源"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-24T12:46:58.000Z"}],["meta",{"property":"article:author","content":"claroja"}],["meta",{"property":"article:modified_time","content":"2025-02-24T12:46:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"process\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-24T12:46:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"claroja\\",\\"url\\":\\"https://claroja.github.io\\"}]}"]]},"headers":[{"level":3,"title":"构造方法","slug":"构造方法","link":"#构造方法","children":[]},{"level":3,"title":"应用","slug":"应用","link":"#应用","children":[]}],"git":{"createdTime":1740401218000,"updatedTime":1740401218000,"contributors":[{"name":"Claroja","email":"63183535@qq.com","commits":1}]},"readingTime":{"minutes":3.41,"words":1024},"filePathRelative":"4编程语言/3python/9进程/process.md","localizedDate":"2025年2月24日","excerpt":"<h1> process</h1>\\n<p>进程是资源分配的最⼩单位\\n进程间不能共享全局变量, 每个进程都会复制一份主进程的变量到自己的空间</p>\\n<h3> 构造方法</h3>\\n<p><code>class multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)</code>\\n<code>multiprocessing.Process</code> 和 <code>threading.Thread</code> 有相同的设计.</p>\\n<table>\\n<thead>\\n<tr>\\n<th>参数</th>\\n<th>描述</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>run()</td>\\n<td>不直接操作, 只重写</td>\\n</tr>\\n<tr>\\n<td>start()</td>\\n<td>启动进程</td>\\n</tr>\\n<tr>\\n<td>join([timeout])</td>\\n<td>阻塞主进程(调用进程), 等待被调用了<code>join()</code>的<code>process</code>执行玩完毕</td>\\n</tr>\\n<tr>\\n<td>name</td>\\n<td>进程名称</td>\\n</tr>\\n<tr>\\n<td>is_alive()</td>\\n<td>是否存活</td>\\n</tr>\\n<tr>\\n<td>daemon</td>\\n<td>在<code>start()</code>方法之前设置</td>\\n</tr>\\n<tr>\\n<td>pid</td>\\n<td>进程的id, 在开始前为<code>None</code></td>\\n</tr>\\n<tr>\\n<td>exitcode</td>\\n<td>进程退出时的code</td>\\n</tr>\\n<tr>\\n<td>authkey</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>sentinel</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>terminate()</td>\\n<td>使用<code>SIGTERM</code>结束进程, 其子进程不会结束, 而会成为orphaned</td>\\n</tr>\\n<tr>\\n<td>kill()</td>\\n<td>使用<code>SIGKILL</code>结束进程</td>\\n</tr>\\n<tr>\\n<td>close()</td>\\n<td>关闭进程,并释放所有资源</td>\\n</tr>\\n</tbody>\\n</table>","copyright":{"author":"王新宇"},"autoDesc":true}');export{t as data};
