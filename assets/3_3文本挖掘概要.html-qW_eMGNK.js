import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as s,c as e,a as i,b as l}from"./app-nD1Z-e8V.js";const t="/assets/逐词反转-60xUAf12.png",n="/assets/签名文件-PUBvP4nn.png",o="/assets/向量空间模型1-h7VnKQY6.png",r="/assets/向量空间模型2-aZZFH3Wh.png",p="/assets/向量空间模型3-cMJMjezF.png",m="/assets/向量空间模型4-mA9QGoFq.png",c="/assets/向量空间模型5-c7pwNJzt.png",h="/assets/向量空间模型6--BGSTAh0.png",d="/assets/向量空间模型7--FXYSm5u.png",g={},u=i('<ol><li><p>文本挖掘的应用</p><ol><li>运用文本挖掘于公司治理</li><li>SocialBot互动模式设计</li></ol></li><li><p>文本挖掘的基本概念</p><ol><li>基本信息检索技术: 全文扫描、签名文件、逐项反转、控制字汇、关键词索引</li><li>进阶信息检索技术: 向量空间模型</li></ol></li><li><p>文本挖掘的处理流程</p></li></ol><h2 id="信息检索-information-retrieval" tabindex="-1"><a class="header-anchor" href="#信息检索-information-retrieval" aria-hidden="true">#</a> 信息检索(Information Retrieval)</h2><p>建立传统图书信息服务的三大要素</p><ol><li>书(知识的重要化身)</li><li>图书馆(知识的殿堂)</li><li>图书馆员(知识的保护者与传播的代理人)</li></ol><p>网络的世界就是一个虚拟化的电子图书馆</p><ol><li>书有了新的型式(Web Page,Net News,Image,BBS,...)</li><li>图书馆有了新的建筑方法(WebServer,ImageDB,...)</li><li>图书馆员有了新的竞争者(Search Engine:百度,谷歌,...)</li></ol><p>检索的方法</p><ol><li>全文扫描苗（Full-TextScanning)</li><li>逐项反转(Inversion ofTerms)</li><li>签名文件 (Signature File)</li><li>向量空间模型(Vector Space Model)</li><li>概率式检索模型(Probabilistic Retrieval Model)</li><li>神经网络模型(Neural NetworkModel)</li></ol><h2 id="全文扫描-full-text-scanning" tabindex="-1"><a class="header-anchor" href="#全文扫描-full-text-scanning" aria-hidden="true">#</a> 全文扫描(Full-Text Scanning)</h2><p>此法又称之为逐字比对法</p><ol><li>将待查的字符串直接和文件字符串进行快速字符串比对</li><li>文件不多且异动频繁时有用</li></ol><p>全文扫描不需要建索引</p><p>全文扫描之优点</p><ol><li>简化数据库中数据的增删与更新的工作</li><li>不需额外的空间来储存索引</li></ol><p>全文扫描之缺点</p><ol><li>检索反应时间缓慢</li></ol><h2 id="关键词-keyword" tabindex="-1"><a class="header-anchor" href="#关键词-keyword" aria-hidden="true">#</a> 关键词(Keyword)</h2><p>关键词(Keyword)</p><p>不会查询所有有出现“的”（FunctionWord)的文章</p><p>文件语意的抽取层次是以什么为单位: 字、词、词组、概念(SingleTerm or Phrase Term)或N-Gram</p><p>关键词的确定</p><ol><li><p>人工(专家)</p><ol><li>品质很高</li><li>属于控制字汇(Controlled Vocabulary)</li></ol></li><li><p>自动</p><ol><li>成本(人力，时间)低</li><li>属于非控制字汇(Non-Controlled Vocabulary)</li></ol></li></ol><h2 id="控制字汇" tabindex="-1"><a class="header-anchor" href="#控制字汇" aria-hidden="true">#</a> 控制字汇</h2><p>控制字汇是事先由专家学者所制定的字汇集,大小约在2000个左右</p><p>自动建构关键词(非控制字汇)所得到的字汇大小约为控制字汇的100倍以上,但它提供了更弹性化及多元化的检索方式</p><h2 id="非控制字汇" tabindex="-1"><a class="header-anchor" href="#非控制字汇" aria-hidden="true">#</a> 非控制字汇</h2><p>自动建构关键词(非控制字汇)的方法常采用Inverse DocumentFrequency(IDF)的方式行之</p>',27),_=l("p",null,[l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"D"),l("mi",null,"F"),l("mo",null,"="),l("mi",null,"l"),l("mi",null,"o"),l("msub",null,[l("mi",null,"g"),l("mn",null,"2")]),l("mo",{stretchy:"false"},"("),l("mi",null,"N"),l("mi",{mathvariant:"normal"},"/"),l("mi",null,"n"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"DF = log_2 (N/n)")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6833em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"D"),l("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"F"),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),l("span",{class:"mrel"},"="),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),l("span",{class:"mord mathnormal"},"o"),l("span",{class:"mord"},[l("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t vlist-t2"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.3011em"}},[l("span",{style:{top:"-2.55em","margin-left":"-0.0359em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mtight"},"2")])])]),l("span",{class:"vlist-s"},"​")]),l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.15em"}},[l("span")])])])])]),l("span",{class:"mopen"},"("),l("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),l("span",{class:"mord"},"/"),l("span",{class:"mord mathnormal"},"n"),l("span",{class:"mclose"},")")])])])],-1),f=i('<ol><li>N是指有多少篇文章 (N=5)</li><li>n 是指某个词出现在多少篇文章中 (加势大周(n=1),的(n=5))</li></ol><p>IDF代表着信息量,由IDF的大小我们可以得知一个词的重要程度</p><ol><li>IDF越大代表这个词越重要，也越是我们想要的关键词</li><li>IDF越小代表这个词的索引价值也越低</li><li>加势大周(IDF=log25=2.32),的(IDF=log21=0-&gt;完全无检索价值)</li></ol><p>✨每篇文章都出现的词, 不重要; 反之, 重要. (概率小的事件, 携带的信息量越大)</p><p>“说”&gt;“蝶血案”&gt;“因”=“和”, 此现象不甚合理，why?Howtoresolve?</p><p>✨IDF的前提是文章量足够大</p><p>在将每个词的IDF算出后,我们仅需订出一个阀值(Threshold)来过滤小于此值的词。其所剩下的即是我们所需的关键词</p><p>这些被过滤掉的词我们称之为StopWords</p><p>在英文中,因为英文词都有很复杂的词类变化,如查询一词就有一般都以原型储存“search&quot;”，“searched”，“searching”，“searches&quot;等变化，为检索方便，</p><p>建立关键词的程序(抽取层次:词)</p><ol><li>读取文献</li><li>分词(中文)</li><li>利用 Suffix String 将 Word 重整至最基本原型(Stem Word)(英文)</li><li>计算每个Word 的IDF</li><li>利用一个阀值(Threshold) <ol><li>选出代表文献的关键词及其IDF</li><li>产生Stop Words</li></ol></li></ol><h2 id="逐项反转-inversion-ofterms" tabindex="-1"><a class="header-anchor" href="#逐项反转-inversion-ofterms" aria-hidden="true">#</a> 逐项反转(Inversion ofTerms)</h2><p>逐项反转(Inversion ofTerms)法一般称为lnverted File</p><p>其主要精神是利用繁复的索引来提高检索的效率: 文件搜寻时仅需比对索引,无需进一步比对文件内容</p><p>利用逐项反转法,每一文件皆可利用反转其本身文件的内容,记录这些文字的位置，以表达文件的内涵</p><figure><img src="'+t+'" alt="逐词反转" tabindex="0" loading="lazy"><figcaption>逐词反转</figcaption></figure><p>若以“字”为反转单位则称之为逐字反转(Inversion of Characters)法</p><p>若以“词”为反转单位则称之为逐词反转(Inversion of Words)法</p><p>此法所需之索引空间很大(通常较原文空间多出50%~300%),不过查询速度确实很快</p><p>关键词和关键词索引之区分</p><p>由于建立这种索引的方法并不困难,且检索的效率相当高,故此法已普遍的应用在商业化的产品上</p><p>此法相对于其它方法较易与同义词词典结合,较有利于同义词的处理</p><p>有了这样的索引结构,我们很容易的利用布尔运算来达到检索的目的,且速度相当快</p><ol><li>想查有A和 B 同时出现的文章 (A and B)</li><li>想查有A或B同时出现的文章 (A or B)</li><li>想查有 A出现但 B 不出现的文章(A and not B)</li><li>想查有A和B同时出现在同一段的文章</li><li>想查有A和B同时出现在同一句的文章</li></ol><h2 id="签名文件-signature-file" tabindex="-1"><a class="header-anchor" href="#签名文件-signature-file" aria-hidden="true">#</a> 签名文件(Signature File)</h2><p>签名文件是逐项反转法和全文扫瞄的综合体</p><p>✨签名文件比逐项反转慢, 比全文扫描快. 比逐项反转索引小.</p><p>签名檔利用重迭编码(Superimposed Coding)的技巧,将文件转换成一固定长度的签名(Signature)以加速字符串比对</p><p>基本上文件中每一出现的词会有一定长的数字编码为其词签名(Word Signature),而文件签名(Document Signature)即是所有词签名的重迭编码. 如文件出现“信息”与“检索”两词,若“信息”的词编码为“10100011&quot;,而“检索”的词编码为“10101111&quot;,则重迭编码后的文件编码为“10101111&quot;(即是将所有对应位OR起来).</p><figure><img src="'+n+'" alt="签名文件" tabindex="0" loading="lazy"><figcaption>签名文件</figcaption></figure><p>✨结果是0, 一定没有关键词. 结果是1, 可能没有关键词.</p><p>签名文件的方法基本上是一种两段式的搜寻方法。查询字符串时先将查询字符串以前述方法建立查询签名(Query Signature),再将查询签名与所有文件签名一一比对(只需比对查询签名为1的位位置),只有查询签名为1的位位置所对应的文件签名也为1时才需进一步作检测. 查询签名和文件签名做and后的结果和查询签名一样的话则此文件通过第一阶段的检测</p><p>通过第一阶段的检测并不代表一定含有查询字符串(未通过者则一定没有)故需第二阶段之检测</p><p>第二阶段之检测实际上就是利用全文扫瞄的方法,将通过(第一阶段)签名测试的文件内容一一读出,并与查询字符串做精确比对. 通过第一阶段检测的文章，一般来说需为极少数，否则需修改编码的机制</p><p>签名文件的比对流程:</p><ol><li>将查询编码成查询签名(Query Signature)</li><li>第一阶段的搜寻(Filter Out Most of theUndesired Documents): 将查询签名与所有文件签名一一比对 (作 and)</li><li>第二阶段的搜寻 (收尾): Full Text Scanning</li><li>产生查询结果</li></ol><p>签名文件的方法所需的索引空间一般较逐项反转法节省,但比全文扫瞄法耗费空间: 全文扫瞄法&lt;签名文件&lt;逐项反转法 (大)</p><p>签名文件的方法检索速度虽比逐项反转法慢,但比全文扫瞄法又快了许多: 全文扫瞄法&lt;签名文件&lt;逐项反转法(快)</p><p>虽然签名文件的方法有折衷的优越性,但是其扩充性较低(尤其是删及改)。虽然一度引起学界高度的兴趣,但西文实用系统很少采用签名文件的方法: 中文而言，此法恰可适用</p><h2 id="向量空间模型-vector-space-model" tabindex="-1"><a class="header-anchor" href="#向量空间模型-vector-space-model" aria-hidden="true">#</a> 向量空间模型(Vector Space Model)</h2><p>由Gerard Salton所提出,并根据此模型发展出Smart System</p><p>它将每一个文件(Document)及查询(Query)表示成N 维空间坐标上的点，每一个维度代表一个关键词，在它维度上的值是根据关键词的TF*关键词的IDF 来得到</p><p>通过计算点与点之间的距离(相似度计算－SimilarityComputation)来找出和此查询相近似的文件 (距离越短越相近)并加以排序输出(Document Ranking)</p><p><img src="'+o+'" alt="向量空间模型1" loading="lazy"><img src="'+r+'" alt="向量空间模型2" loading="lazy"><img src="'+p+'" alt="向量空间模型3" loading="lazy"><img src="'+m+'" alt="向量空间模型4" loading="lazy"><img src="'+c+'" alt="向量空间模型5" loading="lazy"><img src="'+h+'" alt="向量空间模型6" loading="lazy"><img src="'+d+'" alt="向量空间模型7" loading="lazy"></p>',44),y=[u,_,f];function S(v,F){return s(),e("div",null,y)}const D=a(g,[["render",S],["__file","3_3文本挖掘概要.html.vue"]]);export{D as default};
