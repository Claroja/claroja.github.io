const e=JSON.parse('{"key":"v-22c49e71","path":"/%E5%89%8D%E7%AB%AF/vue/4%E5%AF%B9%E8%B1%A1/%E5%93%8D%E5%BA%94%E5%BC%8Fref.html","title":"响应式ref","lang":"zh-CN","frontmatter":{"description":"响应式ref 应用: 不使用ref()来处理响应式对象, 而是使用底层的reactive() 建议使用ref()仅用来处理基础数据, 或者将基础数据放在对象里, 用reactive()来处理 作用: 定义一个响应式的数据 语法: const xxx = ref(initValue) 创建一个包含响应式数据的引用对象(reference对象，简称ref对象)。 JS中操作数据: xxx.value 模板中读取数据: 不需要.value，直接：&lt;div&gt;{{xxx}}&lt;/div&gt; 备注： 接收的数据可以是：基本类型、也可以是对象类型。 基本类型的数据: 响应式依然是靠Object.defineProperty()的get与set完成的。 对象类型的数据: 内部 “ 求助 ”了Vue3.0中的一个新函数reactive函数, 底层是ES6的proxy 拓展: shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。","head":[["meta",{"property":"og:url","content":"https://claroja.github.io/%E5%89%8D%E7%AB%AF/vue/4%E5%AF%B9%E8%B1%A1/%E5%93%8D%E5%BA%94%E5%BC%8Fref.html"}],["meta",{"property":"og:site_name","content":"Claroja"}],["meta",{"property":"og:title","content":"响应式ref"}],["meta",{"property":"og:description","content":"响应式ref 应用: 不使用ref()来处理响应式对象, 而是使用底层的reactive() 建议使用ref()仅用来处理基础数据, 或者将基础数据放在对象里, 用reactive()来处理 作用: 定义一个响应式的数据 语法: const xxx = ref(initValue) 创建一个包含响应式数据的引用对象(reference对象，简称ref对象)。 JS中操作数据: xxx.value 模板中读取数据: 不需要.value，直接：&lt;div&gt;{{xxx}}&lt;/div&gt; 备注： 接收的数据可以是：基本类型、也可以是对象类型。 基本类型的数据: 响应式依然是靠Object.defineProperty()的get与set完成的。 对象类型的数据: 内部 “ 求助 ”了Vue3.0中的一个新函数reactive函数, 底层是ES6的proxy 拓展: shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-30T12:42:23.000Z"}],["meta",{"property":"article:author","content":"claroja"}],["meta",{"property":"article:modified_time","content":"2023-11-30T12:42:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"响应式ref\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-11-30T12:42:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"claroja\\",\\"url\\":\\"https://claroja.github.io\\"}]}"]]},"headers":[],"git":{"createdTime":1701348143000,"updatedTime":1701348143000,"contributors":[{"name":"claroja","email":"63183535@qq.com","commits":1}]},"readingTime":{"minutes":0.98,"words":294},"filePathRelative":"前端/vue/4对象/响应式ref.md","localizedDate":"2023年11月30日","excerpt":"<h1> 响应式ref</h1>\\n<p>应用:</p>\\n<ul>\\n<li>不使用<code>ref()</code>来处理响应式对象, 而是使用底层的<code>reactive()</code></li>\\n<li>建议使用<code>ref()</code>仅用来处理基础数据, 或者将基础数据放在对象里, 用<code>reactive()</code>来处理\\n作用: 定义一个响应式的数据\\n语法: <code>const xxx = ref(initValue)</code></li>\\n<li>创建一个包含响应式数据的引用对象(reference对象，简称ref对象)。</li>\\n<li>JS中操作数据: <code>xxx.value</code></li>\\n<li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;{{xxx}}&lt;/div&gt;</code>\\n备注：</li>\\n<li>接收的数据可以是：基本类型、也可以是对象类型。</li>\\n<li>基本类型的数据: 响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li>\\n<li>对象类型的数据: 内部 “ 求助 ”了Vue3.0中的一个新函数<code>reactive</code>函数, 底层是ES6的proxy\\n拓展:</li>\\n<li>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li>\\n</ul>","copyright":{"author":"王新宇"},"autoDesc":true}');export{e as data};
