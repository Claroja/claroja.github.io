import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as i,c as l,e as a}from"./app-0JgdiRQ-.js";const t={},r=a(`<h1 id="simpleimplement" tabindex="-1"><a class="header-anchor" href="#simpleimplement" aria-hidden="true">#</a> simpleImplement</h1><p>推荐系统</p><h2 id="原始数据" tabindex="-1"><a class="header-anchor" href="#原始数据" aria-hidden="true">#</a> 原始数据</h2><ol><li><p>文章表，记录了文章的基本信息，只取目前还在分享的文章，既<code>eventType==CONTENT SHARED</code> articles_df:</p><ul><li>timestamp：文章发表的时间</li><li>eventType：共两个分类，CONTENT SHARED（文章正在被分享） CONTENT REMOVED（文章已经被删除）</li><li>contentId：文章的Id</li><li>authorPersonId：作者的Id</li><li>authorSessionId：作者回话Id</li><li>authorUserAgent：作者单位</li><li>authorRegion：作者地区</li><li>authorCountry：作者国家</li><li>contentType：共 个份额里，HTML（网页）</li><li>url：文章的链接</li><li>title：文章标题</li><li>text：文章内容</li><li>lang：文章语言</li></ul></li><li><p>交互表，记录了用户与文章的交互信息 interactions_df：交互表</p><ul><li>timestamp：交互时间</li><li>eventType：公有5分类，VIEW（查看）LIKE（喜欢）COMMENT CREATED（评论）BOOKMARK（收藏）FOLLOW（关注）</li><li>contentId：文章的Id</li><li>personId：用户的Id</li><li>sessionId：回话Id</li><li>userAgent：客户端类型</li><li>userRegion：用户地区</li><li>userCountry：用户国家</li></ul></li></ol><h2 id="用户行为数学转化" tabindex="-1"><a class="header-anchor" href="#用户行为数学转化" aria-hidden="true">#</a> 用户行为数学转化</h2><p>给<code>eventType</code>进行权重定义，这就是一个自然问题转换为数学问题的过程。不同的event有不同的评分，我们认为评论是的用户对文章的最大认可。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>{
   &#39;VIEW&#39;: 1.0,
   &#39;LIKE&#39;: 2.0, 
   &#39;BOOKMARK&#39;: 2.5, 
   &#39;FOLLOW&#39;: 3.0,
   &#39;COMMENT CREATED&#39;: 4.0,  
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="模型评估" tabindex="-1"><a class="header-anchor" href="#模型评估" aria-hidden="true">#</a> 模型评估</h2><p>在测试集取用户交互的一个item, 放在随机抽取的100个用户没有交互的item中, 然后进行排序. 看测试集这个item在第几位.</p><ol><li>遍历每一个user 2. 遍历测试集中user交互的每个item 3.1 抽取100个该user没有交互的item(这里假设没有交互的item就是和user不相关的，因为user可能仅仅是因为没有注意的该item) 3.2 从1次交互和100个未交互的item中，让模型产出一个推荐的排序 3.3 从推荐的排序中计算Top-N accuracy metrics</li><li>汇总global Top-N accuracy metrics</li></ol><p>Top-N accuracy 衡量的是交互的item命中top N item的概率</p><h2 id="模型" tabindex="-1"><a class="header-anchor" href="#模型" aria-hidden="true">#</a> 模型</h2><h3 id="popularity-model" tabindex="-1"><a class="header-anchor" href="#popularity-model" aria-hidden="true">#</a> Popularity model</h3><p>计算最受欢迎的item</p><h3 id="content-based-filtering-model" tabindex="-1"><a class="header-anchor" href="#content-based-filtering-model" aria-hidden="true">#</a> Content-Based Filtering model</h3><p>用一个用所有的item的profile的平均数, 作为该用户的profile. 然后用该profile和所有item比较距离, 排序.</p><h3 id="colaboratory-filter-model" tabindex="-1"><a class="header-anchor" href="#colaboratory-filter-model" aria-hidden="true">#</a> colaboratory filter model</h3><p>svd 矩阵分解</p><h3 id="hybridization-model" tabindex="-1"><a class="header-anchor" href="#hybridization-model" aria-hidden="true">#</a> hybridization model</h3><p>就是将不同的排序给权重, 然后融合, 给出综合的排序</p><p>kaggle里面代码的流程图 <a href="./simpleImplement/1.jpg"></a></p><p>参考: https://www.kaggle.com/code/gspmoreira/recommender-systems-in-python-101/notebook https://www.cxymm.net/article/qq_45531594/108899674</p>`,22),d=[r];function n(o,s){return i(),l("div",null,d)}const h=e(t,[["render",n],["__file","simpleImplement.html.vue"]]);export{h as default};
