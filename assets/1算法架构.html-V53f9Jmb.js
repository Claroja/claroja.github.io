const t=JSON.parse('{"key":"v-36075f88","path":"/1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/2%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/2%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/1%E6%8E%A8%E8%8D%90%E6%A1%86%E6%9E%B6/1%E7%AE%97%E6%B3%95%E6%9E%B6%E6%9E%84.html","title":"RecSys_算法架构","lang":"zh-CN","frontmatter":{"description":"RecSys_算法架构 实际的工业推荐系统，如果粗分的化，经常讲的有两个阶段。首先是召回，主要根据用户部分特征，从海量的物品库里，快速找回一小部分用户潜在感兴趣的物品，然后交给排序环节，排序环节可以融入较多特征，使用复杂模型，来精准地做个性化推荐。召回强调快，排序强调准。 更细致地看实用的推荐系统，一般会有四个环节： 召回 当用户以及内容量比较大的时候，往往先通过召回策略，将百万量级的内容先缩小到百量级。 粗排 有时候因为每个用户召回环节返回的物品数量还是太多，怕排序环节速度跟不上，所以可以在召回和精排之间加入一个粗排环节，通过少量用户和物品特征，简单模型，来对召回的结果进行个粗略的排序，在保证一定精准的前提下，进一步减少往后传送的物品数量，粗排往往是可选的，可用可不同，跟场景有关。 精排 使用你能想到的任何特征，可以上你能承受速度极限的复杂模型，尽量精准地对物品进行个性化排序。 重排 排序完成后，传给重排环节，传统地看，这里往往会上各种技术及业务策略，比如去已读、去重、打散、多样性保证、固定类型物品插入等等，主要是技术产品策略主导或者为了改进用户体验的。","head":[["meta",{"property":"og:url","content":"https://claroja.github.io/1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/2%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/2%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/1%E6%8E%A8%E8%8D%90%E6%A1%86%E6%9E%B6/1%E7%AE%97%E6%B3%95%E6%9E%B6%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"Claroja"}],["meta",{"property":"og:title","content":"RecSys_算法架构"}],["meta",{"property":"og:description","content":"RecSys_算法架构 实际的工业推荐系统，如果粗分的化，经常讲的有两个阶段。首先是召回，主要根据用户部分特征，从海量的物品库里，快速找回一小部分用户潜在感兴趣的物品，然后交给排序环节，排序环节可以融入较多特征，使用复杂模型，来精准地做个性化推荐。召回强调快，排序强调准。 更细致地看实用的推荐系统，一般会有四个环节： 召回 当用户以及内容量比较大的时候，往往先通过召回策略，将百万量级的内容先缩小到百量级。 粗排 有时候因为每个用户召回环节返回的物品数量还是太多，怕排序环节速度跟不上，所以可以在召回和精排之间加入一个粗排环节，通过少量用户和物品特征，简单模型，来对召回的结果进行个粗略的排序，在保证一定精准的前提下，进一步减少往后传送的物品数量，粗排往往是可选的，可用可不同，跟场景有关。 精排 使用你能想到的任何特征，可以上你能承受速度极限的复杂模型，尽量精准地对物品进行个性化排序。 重排 排序完成后，传给重排环节，传统地看，这里往往会上各种技术及业务策略，比如去已读、去重、打散、多样性保证、固定类型物品插入等等，主要是技术产品策略主导或者为了改进用户体验的。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-25T10:13:52.000Z"}],["meta",{"property":"article:author","content":"claroja"}],["meta",{"property":"article:modified_time","content":"2025-02-25T10:13:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RecSys_算法架构\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-25T10:13:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"claroja\\",\\"url\\":\\"https://claroja.github.io\\"}]}"]]},"headers":[{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1740478432000,"updatedTime":1740478432000,"contributors":[{"name":"Claroja","email":"63183535@qq.com","commits":1}]},"readingTime":{"minutes":1.45,"words":436},"filePathRelative":"1机器学习/2应用场景/2推荐系统/1推荐框架/1算法架构.md","localizedDate":"2025年2月25日","excerpt":"<h1> RecSys_算法架构</h1>\\n<p>实际的工业推荐系统，如果粗分的化，经常讲的有两个阶段。首先是召回，主要根据用户部分特征，从海量的物品库里，快速找回一小部分用户潜在感兴趣的物品，然后交给排序环节，排序环节可以融入较多特征，使用复杂模型，来精准地做个性化推荐。召回强调快，排序强调准。</p>\\n<p>更细致地看实用的推荐系统，一般会有四个环节：</p>\\n<ol>\\n<li>\\n<p>召回</p>\\n<p>当用户以及内容量比较大的时候，往往先通过召回策略，将百万量级的内容先缩小到百量级。</p>\\n</li>\\n<li>\\n<p>粗排</p>\\n<p>有时候因为每个用户召回环节返回的物品数量还是太多，怕排序环节速度跟不上，所以可以在召回和精排之间加入一个粗排环节，通过少量用户和物品特征，简单模型，来对召回的结果进行个粗略的排序，在保证一定精准的前提下，进一步减少往后传送的物品数量，粗排往往是可选的，可用可不同，跟场景有关。</p>\\n</li>\\n<li>\\n<p>精排</p>\\n<p>使用你能想到的任何特征，可以上你能承受速度极限的复杂模型，尽量精准地对物品进行个性化排序。</p>\\n</li>\\n<li>\\n<p>重排</p>\\n<p>排序完成后，传给重排环节，传统地看，这里往往会上各种技术及业务策略，比如去已读、去重、打散、多样性保证、固定类型物品插入等等，主要是技术产品策略主导或者为了改进用户体验的。</p>\\n</li>\\n</ol>","copyright":{"author":"王新宇"},"autoDesc":true}');export{t as data};
