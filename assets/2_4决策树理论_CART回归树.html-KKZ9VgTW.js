import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as e,c as n,a as s,b as a,d as i}from"./app-7knaTE3M.js";const l="/assets/1-iNc9jUmj.png",o="/assets/2-WZbj6cNb.png",r="/assets/3-g7bssCm3.png",g="/assets/4-QFjqP9X0.png",p="/assets/6-E5rp2afm.png",c="/assets/7-iN8W243o.gif",f="/assets/8-TPJ11Z8z.png",d="/assets/9-It-9b6Nq.png",m="/assets/10-fAwWL7im.png",u="/assets/11-qyjudqe2.png",_="/assets/12-kQalNSyn.png",h="/assets/13-PXnuJXzz.png",x="/assets/14-Jyle-acV.png",b="/assets/15-Xu5h1Iyy.png",y="/assets/16-WFTJA7G-.png",z="/assets/16-WFTJA7G-.png",w="/assets/18-bt4zT1so.png",T={},k=s('<h1 id="regression" tabindex="-1"><a class="header-anchor" href="#regression" aria-hidden="true">#</a> regression</h1><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ol><li>cart树回归问题，是计算ssr(sum of squared residual),寻找最小的ssr作为特征的分裂点</li><li>每个叶子节点的输出是该所包含连续变量的均值</li></ol><h2 id="推演" tabindex="-1"><a class="header-anchor" href="#推演" aria-hidden="true">#</a> 推演</h2><p>在医学实验中, 更多的药剂量(dosages, x轴)会有更好的治疗效果(effectiveness, y轴)</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们可以拟合一条直线, 根据这条直线, 如果药剂量是27mg, 则会有62%的效果.</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>但是数据分布并不总是如上那么简单.</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在这种情况下, 拟合直线就没有作用了.</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>所以需要一个非线性的模型, 比如回归树(Regression Tree), 回归树也是一种决策树(Decision Tree). 回归树的每个叶子节点是一个数值, 而分类树(Classification Trees)则是分类集合.</p>',13),N=a("p",null,[i("比如, 如果药剂量"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mo",null,">"),a("mo",null,"="),a("mn",null,"14.5")]),a("annotation",{encoding:"application/x-tex"},">= 14.5")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.5782em","vertical-align":"-0.0391em"}}),a("span",{class:"mrel"},">="),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"14.5")])])]),i(" and "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mo",null,"<"),a("mn",null,"23.5")]),a("annotation",{encoding:"application/x-tex"},"<23.5")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.5782em","vertical-align":"-0.0391em"}}),a("span",{class:"mrel"},"<"),a("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"23.5")])])]),i(", 我们可以获得四个观测值, 他们的均值是100%. 也就是说回归树用均值100%, 来预测药剂量在14.5和23.5之间的样本值.")],-1),v=s('<figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>同理, 不同药剂量都对应了不同的效果均值:</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="分割点选择" tabindex="-1"><a class="header-anchor" href="#分割点选择" aria-hidden="true">#</a> 分割点选择</h2><p>Let&#39;s build the tree. The first thing we do is figure out why we start by asking if <code>Dosage &lt; 14.5</code>.</p><p>首先, 选择最小的药剂量3和倒数第二药剂量间隔作为分隔点, 下图中红色虚线所示, 将观测点分为了两部分. 药剂量 &lt; 3部分的效果均值是0, 药剂量&gt;=3的效果均值是38.8(图中绿色线).</p><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当药剂量 &lt; 3, 预测值为0, 预测是非常准的.</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当药剂量 &gt;3, 预测值为38.8, 预测则非常差.</p><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>对于每一个观测值, 我们都可以计算期预测值(绿色线)到真实值(黄色点)的距离, 既残差(residual), 图中黑色虚线所示. 我们使用残差来评估预测的准确性.</p><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们将残差的平方和作为Y轴, 将药剂量分隔点作为X轴, 绘制药剂量等于3时的残差图.</p><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>绘制所有药剂量分隔点的残差图</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>药剂量 &lt; 14.5时, 有最小的残差平方和, 所以选择药剂量 = 14.5作为第一个分裂点.</p><figure><img src="'+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>同理, 我们可以将药剂量&lt;14.5的部分进一步分隔成3部分. 其中</p><ol><li>11.5 &lt;= 药剂量 &lt; 14.5: 只包含1个观测点</li><li>9 &lt;= 药剂量 &lt; 11.5: 只包含1个观测点</li><li>药剂量&lt; 9: 包含4个观测点, 因为这个4个点值相同, 所以不需要再分隔.</li></ol><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当模型很好拟合训练集时, 意味着过拟合, 将会在测试集表现很糟糕. 在机器学习领域里, 我们说有较低的偏差(bias)和较高的方差(variance). 可以通过减枝(prune)来避免过拟合.</p><p>设置节点包含观测点的最小值为7个. 因为只有6个观测值在药剂量&lt;14.5区域, 所以将不再分隔该节点, 该节点的预测值是6个观测点的均值, 4.2%.</p><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>由于药剂量&gt;=14.5区域有多余7个观测点, 所以我们可以继续分裂:</p><figure><img src="'+z+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>对于多个属性的树模型, 方法同分类树.</p><figure><img src="'+w+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>refs: https://www.youtube.com/watch?v=g9c66TUylZ4</p>',30),M=[k,N,v];function j(q,A){return e(),n("div",null,M)}const X=t(T,[["render",j],["__file","2_4决策树理论_CART回归树.html.vue"]]);export{X as default};
