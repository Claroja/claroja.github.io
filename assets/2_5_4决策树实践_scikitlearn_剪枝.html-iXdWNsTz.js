import{_ as l}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as n,o as e,c as i,b as s,d as a,e as m,w as c,a as r}from"./app-nD1Z-e8V.js";const p="/assets/1-HRKcI9A5.png",o="/assets/2-lBU1LLHy.png",h="/assets/3-pfgaFaSm.png",g="/assets/4-9L3RcIqf.png",u="/assets/5-DiUyVQqE.png",d="/assets/6-4vvLWUND.png",_="/assets/7-SVMI9rdR.png",x="/assets/8-wF2DpOGn.png",y="/assets/9-XbhTNHLt.png",w="/assets/10-Nxmtmuqy.png",k="/assets/11-LZymP_ur.png",f="/assets/12-2aCwV8eN.png",b="/assets/13-lDd7kH3e.png",M={},E=s("h1",{id:"剪枝",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#剪枝","aria-hidden":"true"},"#"),a(" 剪枝")],-1),S=s("h2",{id:"问题引入",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#问题引入","aria-hidden":"true"},"#"),a(" 问题引入")],-1),L=r('<figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果下图中红色的观测点来自测试集怎么办? 这些红色的残差值会很大, 而训练集的4个观测值预测效果为100%看起来像是离群值. 也就说, 在训练集上出现了过拟合.</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>一个避免过拟合的方法是删除叶子节点, 适用包含更多观测值的子节点来替代叶子节点. 现在, 14.5 &lt;= 药剂量 &lt; 29的观测值在树的最右侧.</p><p>更大的残差表示在训练集上表现不如之前的不好, 但是在测试集却表现的更好.</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果我们想如下图进一步裁剪枝叶:</p><p><img src="'+g+'" alt="" loading="lazy"><img src="'+u+'" alt="" loading="lazy"></p><p>我们该如何决定使用哪一个被裁剪后的树呢?答案是<code>Cost Complexity Pruning</code></p><h2 id="cost-complexity-pruning" tabindex="-1"><a class="header-anchor" href="#cost-complexity-pruning" aria-hidden="true">#</a> Cost Complexity Pruning</h2><p><code>Cost Complexity Pruning</code>第一步是计算每一棵树的残差平方和.</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如何比较每棵树?</p><p>最弱链接剪枝(Weakest Link Pruning)方法是计算树的得分(Tree Score), 它包含的因素有:</p><ol><li>残差平方和(SSR), 越小，说明树或子树对数据的拟合效果越好</li><li>树复杂度惩罚(Tree complexity Penalty), 叶子节点数量越多，意味着树的结构越复杂，模型可能更容易出现过拟合的情况。当叶子节点数量增加时，“Tree complexity Penalty” 会相应增大，使得 “Tree Score” 降低，从而倾向于选择更简单的树结构</li></ol><p>在剪枝过程中，它会不断比较不同子树的 “Tree Score”，选择得分最高的子树作为最终的模型结构。这样可以有效地去除那些对模型性能提升不大，但却增加了模型复杂度的分支，从而得到一个既具有较好拟合效果，又相对简单的决策树模型，提高模型的泛化能力和可解释性。</p>',16),A=s("p",null,[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"α")]),s("annotation",{encoding:"application/x-tex"},"\\alpha")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α")])])]),a("是一个调优参数，我们会通过“交叉验证”来确定它的值，稍后我们会对此展开更多讨论。就目前而言，让我们先设定"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"α"),s("mo",null,"="),s("mn",null,"10000")]),s("annotation",{encoding:"application/x-tex"},"\\alpha = 10000")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"10000")])])]),a("。")],-1),R=s("p",{class:"katex-block"},[s("span",{class:"katex-display"},[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[s("semantics",null,[s("mrow",null,[s("mi",null,"T"),s("mi",null,"r"),s("mi",null,"e"),s("mi",null,"e"),s("mi",null,"S"),s("mi",null,"c"),s("mi",null,"o"),s("mi",null,"r"),s("mi",null,"e"),s("mo",null,"="),s("mi",null,"S"),s("mi",null,"S"),s("mi",null,"R"),s("mo",null,"+"),s("mi",null,"α"),s("mo",null,"⋅"),s("mi",null,"T")]),s("annotation",{encoding:"application/x-tex"}," TreeScore = SSR + \\alpha \\cdot T ")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"T"),s("span",{class:"mord mathnormal"},"ree"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"S"),s("span",{class:"mord mathnormal"},"core"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7667em","vertical-align":"-0.0833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.00773em"}},"SSR"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4445em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"⋅"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"T")])])])])],-1),T=s("p",null,"计算每棵树的得分:",-1),z=s("figure",null,[s("img",{src:_,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),B=s("p",null,"首先, 创建一课完整的回归树, 该树拟合了所有数据, 包含训练数据和测试数据.",-1),C=s("p",null,[a("当"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"α"),s("mo",null,"="),s("mn",null,"0")]),s("annotation",{encoding:"application/x-tex"},"\\alpha = 0")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"0")])])]),a("时, 该完整的回归树具有最低的得分. 因为, "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"α"),s("mo",null,"="),s("mn",null,"0")]),s("annotation",{encoding:"application/x-tex"},"\\alpha = 0")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"0")])])]),a("时, 树的复杂度惩罚为0, 树的得分就是SSR的值. 就如之前所说, 其子树会有更大的SSR.")],-1),D=s("p",null,[a("我们增加"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"α")]),s("annotation",{encoding:"application/x-tex"},"\\alpha")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α")])])]),a(", 直到有更低的树得分.")],-1),N=s("figure",null,[s("img",{src:x,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),v=s("p",null,[a("在这种情况, 当"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"α"),s("mo",null,"="),s("mn",null,"10000")]),s("annotation",{encoding:"application/x-tex"},"\\alpha = 10000")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"10000")])])]),a("时, 如果我们删除两个叶子节点, 将会获得更低的树得分.")],-1),P=s("figure",null,[s("img",{src:y,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),V=s("p",null,[a("在这种情况, 当"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"α"),s("mo",null,"="),s("mn",null,"15000")]),s("annotation",{encoding:"application/x-tex"},"\\alpha = 15000")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"15000")])])]),a("时, 如果我们删除两个叶子节点, 将会获得更低的树得分.")],-1),H=s("figure",null,[s("img",{src:w,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),q=s("p",null,[a("在这种情况, 当"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"α"),s("mo",null,"="),s("mn",null,"22000")]),s("annotation",{encoding:"application/x-tex"},"\\alpha = 22000")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"22000")])])]),a("时, 如果我们删除两个叶子节点, 将会获得更低的树得分.")],-1),F=s("figure",null,[s("img",{src:k,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),I=s("p",null,[a("回到完整的数据集, 将其分隔为训练集和测试集, 在训练集上, 使用之前的发现的"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"α")]),s("annotation",{encoding:"application/x-tex"},"\\alpha")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α")])])]),a(", 来创建完整的树和一系列的子树, 来最小化树得分.")],-1),U=s("figure",null,[s("img",{src:f,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),W=s("p",null,"现在仅在测试集上计算每棵新树的SSR.",-1),G=s("figure",null,[s("img",{src:b,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),J=s("p",null,[a("在这个案例中, 通过十折交叉验证, 得到最终的"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"α")]),s("annotation",{encoding:"application/x-tex"},"\\alpha")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α")])])]),a(", 当"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"α"),s("mo",null,"="),s("mn",null,"10000")]),s("annotation",{encoding:"application/x-tex"},"\\alpha = 10000")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"10000")])])]),a("时, 有最小的SSR.")],-1),K=s("h2",{id:"参考",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#参考","aria-hidden":"true"},"#"),a(" 参考")],-1),O=s("ul",null,[s("li",null,"https://www.youtube.com/watch?v=D0efHEJsfHo")],-1);function Q(X,Z){const t=n("RouterLink");return e(),i("div",null,[E,S,s("p",null,[a("在"),m(t,{to:"/1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/1%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/3%E6%A0%91%E6%A8%A1%E5%9E%8B/2%E5%86%B3%E7%AD%96%E6%A0%91/2_4%E5%86%B3%E7%AD%96%E6%A0%91%E7%90%86%E8%AE%BA_CART%E5%9B%9E%E5%BD%92%E6%A0%91.html"},{default:c(()=>[a("CART_回归树")]),_:1}),a(", 我们创建了一个回归树.")]),L,A,R,T,z,B,C,D,N,v,P,V,H,q,F,I,U,W,G,J,K,O])}const $=l(M,[["render",Q],["__file","2_5_4决策树实践_scikitlearn_剪枝.html.vue"]]);export{$ as default};
