import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o,c,a as i}from"./app-7knaTE3M.js";const d="/assets/1-PHKoXj9m.png",r="/assets/2-eA3FJ0TP.png",t="/assets/3-IPhJgqbP.png",a={},n=i(`<h1 id="fetch" tabindex="-1"><a class="header-anchor" href="#fetch" aria-hidden="true">#</a> fetch</h1><p><code>git fetch</code>只负责将远程分支复制到本地，比如将<code>remote/master</code>复制到本地的<code>origin/master</code></p><h2 id="api说明" tabindex="-1"><a class="header-anchor" href="#api说明" aria-hidden="true">#</a> api说明</h2><p>更新本地的远程分支(origin/*) <code>get fetch [ORIGIN] [R-BRANCH] [L-BRANCH]</code></p><ul><li><code>git fetch</code> 不带参数则是默认拉取远程ORIGIN仓库, 所有分支(origin/*)</li><li><code>ORIGIN</code> 拉取远程仓库的名称, 默认origin</li><li><code>R-BREANCH</code> 拉取远程仓库的分支名, 在本地的名称为(origin/R-BRANCH)</li><li><code>L-BRANCH</code> 来取远程残酷的分支,并更新本地对应的分支</li></ul><h2 id="应用" tabindex="-1"><a class="header-anchor" href="#应用" aria-hidden="true">#</a> 应用</h2><ol><li>git fetch |这将更新git remote 中所有的远程repo 所包含分支的最新commit-id, 将其记录到.git/FETCH_HEAD文件中</li><li>git fetch remote_repo |这将更新名称为remote_repo 的远程repo上的所有branch的最新commit-id，将其记录。</li><li>git fetch remote_repo remote_branch_name |这将这将更新名称为remote_repo 的远程repo上的分支： remote_branch_name</li><li>git fetch remote_repo remote_branch_name:local_branch_name |这将这将更新名称为remote_repo 的远程repo上的分支： remote_branch_name ，并在本地创建local_branch_name 本地分支保存远端分支的所有数据。</li></ol><p>总结起来, fetch的应用就是:</p><div class="language-s line-numbers-mode" data-ext="s"><pre class="language-s"><code>git fetch origin master //从远程的origin仓库的master分支下载代码到本地的origin/master
git log -p master.. origin/master //比较本地的仓库和远程参考的区别
git merge origin/master //把远程下载下来的代码合并到当前的分支
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意是当前的分支,而不是对应名字的分支。也就是说，如果当前的分支是<code>dev</code>，执行<code>git merge</code>，则是将<code>origin/master</code>与<code>dev</code>合并，而不是和本地的<code>master</code>合并。</p><p>另一个简单的写法是：</p><div class="language-s line-numbers-mode" data-ext="s"><pre class="language-s"><code>git fetch origin branch1:branch2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>首先执行上面的fetch操作，使用远程branch1分支在本地创建branch2(但不会切换到该分支). 如果本地存在branch2分支, 则是使用\`fast forward&#39;方式合并分支</p><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理" aria-hidden="true">#</a> 原理</h2><ol><li><p>假设以下仓库, 通过<code>git clone</code>到本地 <img src="`+d+'" alt="" loading="lazy"> 本地会创建<code>origin/master</code>,<code>origin/dev</code>及<code>master</code>(<code>origin/master</code>复制的)三个分支, 且<code>HEAD</code>指针指向<code>master</code>分支.</p></li><li><p>远程仓库的两个分支<code>origin/master</code>和<code>origin/dev</code>都有了更新.</p><ul><li><p><code>git fetch</code>命令进行本地更新. <code>git fetch</code>是对所有<code>origin/*</code>(这里是<code>origin/master</code>,<code>origin/dev</code>)远程分支进行更新, 比如但不会对本地<code>master</code>分支进行更新 <img src="'+r+'" alt="" loading="lazy"> 如果需要更新本地的<code>master</code>分支, 则需要使用<code>git merge origin master</code></p></li><li><p>本地使用<code>git fetch origin dev</code>更新, 指定分支. 本地没有<code>dev</code>分支, 不会创建, 即使有也不会更新. 因为<code>fetch</code>只更新<code>origin/*</code>的分支 <img src="'+t+'" alt="" loading="lazy"></p></li></ul></li></ol><p>理解<code>fetch</code>的关键, 是理解<code>FETCH_HEAD</code>. 它的含义是某个<code>branch</code>在远程服务器上的最新状态. 这个列表保存在<code>.Git/FETCH_HEAD</code>文件中, 每一行对应一个分支.</p><ul><li>当使用<code>git fetch</code>时, 远程分支的<code>master</code>将作为<code>FETCH_HEAD</code></li><li>当使用<code>git fetch origin dev</code>时, 远程分支的<code>dev</code>将作为<code>FETCH_HEAD</code><code>* branch dev -&gt; FETCH_HEAD</code></li></ul><ul><li>branch source -&gt; FETCH_HEAD</li></ul><p>参考: https://www.cnblogs.com/todototry/p/4095626.html</p>',19),l=[n];function s(h,m){return o(),c("div",null,l)}const _=e(a,[["render",s],["__file","fetch.html.vue"]]);export{_ as default};
