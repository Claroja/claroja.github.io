const t=JSON.parse('{"key":"v-cf5e2c38","path":"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/Concurrency/JavaThreadPool.html","title":"归因谬误","lang":"zh-CN","frontmatter":{"description":"归因谬误 ThreadPoolExecutor 线程池状态 ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量 状态名 高3位 接收新任务 处理阻塞队列任务 说明 RUNNING 111 Y Y SHUTDOWN 000 N Y 不会接收新任务,但会处理阻塞队列剩余任务 STOP 001 N N 会中断正在执行的任务，并抛弃阻塞队列任务 TIDYING 010 - - 任务全执行完毕，活动线程为 0 即将进入终结 TERMINATED 011 - - 终结状态 TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING(高三位表示, RUNNING第一位是1,是负数). 为什么是使用一个int, 存放线程状态和线程数量, 而不是分开存储? 这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作 进行赋值:","head":[["meta",{"property":"og:url","content":"https://claroja.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/Concurrency/JavaThreadPool.html"}],["meta",{"property":"og:site_name","content":"Claroja"}],["meta",{"property":"og:title","content":"归因谬误"}],["meta",{"property":"og:description","content":"归因谬误 ThreadPoolExecutor 线程池状态 ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量 状态名 高3位 接收新任务 处理阻塞队列任务 说明 RUNNING 111 Y Y SHUTDOWN 000 N Y 不会接收新任务,但会处理阻塞队列剩余任务 STOP 001 N N 会中断正在执行的任务，并抛弃阻塞队列任务 TIDYING 010 - - 任务全执行完毕，活动线程为 0 即将进入终结 TERMINATED 011 - - 终结状态 TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING(高三位表示, RUNNING第一位是1,是负数). 为什么是使用一个int, 存放线程状态和线程数量, 而不是分开存储? 这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作 进行赋值:"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-25T13:46:58.000Z"}],["meta",{"property":"article:author","content":"claroja"}],["meta",{"property":"article:modified_time","content":"2023-11-25T13:46:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"归因谬误\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-11-25T13:46:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"claroja\\",\\"url\\":\\"https://claroja.github.io\\"}]}"]]},"headers":[{"level":2,"title":"ThreadPoolExecutor","slug":"threadpoolexecutor","link":"#threadpoolexecutor","children":[]},{"level":2,"title":"线程池状态","slug":"线程池状态","link":"#线程池状态","children":[]},{"level":2,"title":"构造方法","slug":"构造方法","link":"#构造方法","children":[{"level":3,"title":"newFixedThreadPool","slug":"newfixedthreadpool","link":"#newfixedthreadpool","children":[]},{"level":3,"title":"newCachedThreadPool","slug":"newcachedthreadpool","link":"#newcachedthreadpool","children":[]},{"level":3,"title":"newSingleThreadExecutor","slug":"newsinglethreadexecutor","link":"#newsinglethreadexecutor","children":[]}]},{"level":2,"title":"提交任务","slug":"提交任务","link":"#提交任务","children":[]},{"level":2,"title":"停止","slug":"停止","link":"#停止","children":[]},{"level":2,"title":"定时线程池: newScheduledThreadPool","slug":"定时线程池-newscheduledthreadpool","link":"#定时线程池-newscheduledthreadpool","children":[]},{"level":2,"title":"异常处理","slug":"异常处理","link":"#异常处理","children":[]},{"level":2,"title":"Fork/join","slug":"fork-join","link":"#fork-join","children":[]},{"level":2,"title":"其他","slug":"其他","link":"#其他","children":[]},{"level":2,"title":"补充Tomcat原理","slug":"补充tomcat原理","link":"#补充tomcat原理","children":[]}],"git":{"createdTime":1700920018000,"updatedTime":1700920018000,"contributors":[{"name":"claroja","email":"63183535@qq.com","commits":1}]},"readingTime":{"minutes":7.19,"words":2156},"filePathRelative":"编程语言/java/Concurrency/JavaThreadPool.md","localizedDate":"2023年11月25日","excerpt":"<h1> 归因谬误</h1>\\n<h2> ThreadPoolExecutor</h2>\\n<h2> 线程池状态</h2>\\n<p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p>\\n<table>\\n<thead>\\n<tr>\\n<th>状态名</th>\\n<th>高3位</th>\\n<th>接收新任务</th>\\n<th>处理阻塞队列任务</th>\\n<th>说明</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>RUNNING</td>\\n<td>111</td>\\n<td>Y</td>\\n<td>Y</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>SHUTDOWN</td>\\n<td>000</td>\\n<td>N</td>\\n<td>Y</td>\\n<td>不会接收新任务,但会处理阻塞队列剩余任务</td>\\n</tr>\\n<tr>\\n<td>STOP</td>\\n<td>001</td>\\n<td>N</td>\\n<td>N</td>\\n<td>会中断正在执行的任务，并抛弃阻塞队列任务</td>\\n</tr>\\n<tr>\\n<td>TIDYING</td>\\n<td>010</td>\\n<td>-</td>\\n<td>-</td>\\n<td>任务全执行完毕，活动线程为 0 即将进入终结</td>\\n</tr>\\n<tr>\\n<td>TERMINATED</td>\\n<td>011</td>\\n<td>-</td>\\n<td>-</td>\\n<td>终结状态</td>\\n</tr>\\n<tr>\\n<td>TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING(高三位表示, RUNNING第一位是1,是负数).</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>为什么是使用一个int, 存放线程状态和线程数量, 而不是分开存储?</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>进行赋值:</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>","copyright":{"author":"王新宇"},"autoDesc":true}');export{t as data};
