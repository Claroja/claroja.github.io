# 正则表达式



## 正则字符


表达式|说明
--|--
`.`|配置除换行符(`\n`)以外的字符, `re.search('1.3', 'foo123bar')  # 123 `
`\w`|匹配字母或数字或下划线或汉字, `\W`是取反,  `re.search('ba[artz]', 'foobarqux')  # bar`
`\s`|匹配空白字符(空格,制表符`\t`,换行符`\n`), `\S`是取反
`\d`|匹配数字`[0-9]`, `\D`是取反
`\b`|匹配单词的开始或结束, 可以理解为匹配非字符和数字(空格, 制表符`\t`,换行符`\n`,普通符号如`.`), `\B`是取反
`^`|多行模式下匹配字符串的开始, 多行模式下可以理解位开始的`\n`
`$`|单行模式下匹配字符串的结束, 多行模式下可以理解为结尾的`\n`


例子: 
- `\ba\w*\b`匹配以字母a开头的单词——先是某个单词开始处(`\b`)，然后是字母`a`,然后是任意数量的字母或数字(`\w*`)，最后是单词结束处(`\b`)。
- `^`与`$`

    - 单行模式下(整个文本当成一个输入)
        
        比如, 一个网站如果要求你填写的密码号必须为5位数字时，可以使用：`^\d{5}$`. 如果不使用`^`和`$`的话，对于`\d{5}`而言，使用这样的方法就只能保证字符串里包含5连续位数字，而不是整个字符串就是5位数字。

        ```python
        import re
        re.search('^\d{5}$', '12345')  # match 严格的5位数字
        re.search('^\d{5}$', '123456')  # not match  如果是6位则不匹配
        re.search('\d{5}', '123456')  # match 不加`^`和`$`, 则只要包含5位就可以
        ```

    - 多行模式下(先对文本按行切分, 每一行当成一个输入)
        `^`和`$`的意义就变成了匹配行的开始处和结束处。

        ```python
        import re
        re.search('^c', 'a\nb\nc')  # not match, 在单行模式下(默认), `^c`是指整个字符串(字符串中包含换行)的开始.
        re.search('(?m)^c', 'a\nb\nc')  # match, 多行模式下, `^c`既可以指整个字符串的开始, 也可以指行的开始(`\n`), 所以可以匹配.
        ```
- `.`

    ```python
    re.search('foo.bar', 'fooxbar')  # fooxbar
    re.search('foo.bar', 'foo*bar')  # foo*bar
    re.search('foo.bar', 'foo\nbar')  # None 默认情况下`.`不能匹配`\n`
    ```

- `\b`

    ```python
    re.search(r'\bbar', 'foo bar') # bar
    re.search(r'\bbar', 'foo.bar') # bar
    re.search(r'\bbar', 'foobar') # None
    re.search(r'foo\b', 'foo bar') # foo
    re.search(r'foo\b', 'foo.bar')  # foo
    re.search(r'foo\b', 'foobar')  # None
    re.search(r'\bbar\b', 'foo bar baz') # bar
    re.search(r'\bbar\b', 'foo(bar)baz')  # bar
    re.search(r'\bbar\b', 'foobarbaz')  # None
    ```

## 数量限定符

语法|说明
--|--
`*`|重复0次或多次, 贪婪
`+`|重复1次或多次, 贪婪
`?`|重复0次或1次, 贪婪
`*?`|重复0次或多次, 懒惰
`+?`|重复1次或多次, 懒惰
`??`|重复0次或1次, 懒惰
`{n}`|重复n次
`{n,}`|重复n次或多次
`{n,m}`|重复n到m次
`{,}`|任意次


例子:

- `*`

    ```python
    re.search('foo-*bar', 'foobar')  # foobar 零次匹配
    re.search('foo-*bar', 'foo-bar')  # foo-bar 一次匹配
    re.search('foo-*bar', 'foo--bar')  # foo--bar 两次匹配
    re.search('foo.*bar', '# foo $qux@grault % bar #')  # 任意次匹配任意字符
    ```

- `+`

    ```python
    re.search('foo-+bar', 'foobar')  # None 零次匹配
    re.search('foo-+bar', 'foo-bar')  # foo-bar 一次匹配
    re.search('foo-+bar', 'foo--bar')  # foo--bar 两次匹配
    ```

- `?`

    ```python
    re.search('foo-?bar', 'foobar') # foobar 零次匹配
    re.search('foo-?bar', 'foo-bar')  # foo-bar 一次匹配
    re.search('foo-?bar', 'foo--bar')  # None 两次匹配
    ```

- `*?,+?,??`

    ```python
    re.search('<.*>', '%<foo> <bar> <baz>%') # <foo> <bar> <baz>
    ```

    正则表达式`<.*>`的含义:
    1. `<`匹配一个`<`字符
    2. `.*`一系列的字符
    3. `>`匹配一个`>`字符
    但是`>`具体指哪一个呢?有三种情况:
    1. `foo`字符串后面的
    2. `bar`字符串后面的
    3. `baz`字符串后面的

    由于`*`是贪婪的, 所以将匹配最长的字符串, 如果想匹配最短的字符串, 则可以使用`*?`
    ```python
    re.search('<.*?>', '%<foo> <bar> <baz>%')  # foo
    ## 同样的道理也使用+和?
    re.search('<.+>', '%<foo> <bar> <baz>%')  # <foo> <bar> <baz>
    re.search('<.+?>', '%<foo> <bar> <baz>%')  # <foo>
    re.search('ba?', 'baaaa')  # ba
    re.search('ba??', 'baaaa')  # b
    ```




## 逻辑或

语法|说明
--|--
`[]`|中括号内部任意一位, `[0-9]` 匹配0到9的任意一个数字，等同于\d, `[a-z0-9A-Z_]` 匹配任意字符，等同于\w如果不考虑中文
`[^x]`|匹配除`x`以外的任意字符, `[^aeiou]`匹配除了aeiou这几个字母以外的任意字符, `^[^a]` 匹配非a开头的字符
`A|B`|逻辑或,匹配到A或B既停止, `0|1|2|3|4|5|6|7|8|9`等同于`[0-9]`


- `[]`

    ```python
    re.search('ba[artz]', 'foobarqux')  # bar []中只代表一个字符
    re.search('ba[artz]', 'foobazqux')  # baz []中只代表一个字符
    re.search('[)*+|]', '123*456')  # * `*`在`[]`中失效
    re.search('[)*+|]', '123+456')  # + `+`在`[]`中失效, 在正则中有特殊含义的符号, 在`[]`中都会失效
    re.search('[ab\]cd]', 'foo[1]')  # ] `]`有特殊含义, 所以使用转义字符
    re.search('[a-z]', 'FOObar')  # 使用`-`表示连续
    re.search('[0-9][0-9]', 'foo123bar')  # 12
    re.search('[0-9a-fA-f]', '--- a0 ---')  # a 十六进制
    re.search('[-abc]', '123-456') # - 匹配-本身
    re.search('[abc-]', '123-456')  # - 匹配-本身
    re.search('[ab\-c]', '123-456')  # - 如果-有特殊含义, 比如表示连续, 则需要使用转义字符
    re.search('[^0-9]', '12345foo')  # f 当^在[]的开头 f 匹配非0-9的字符
    re.search('[#:^]', 'foo^bar:baz#qux')  # ^ 当^不在[]的开头, 则就表示^本身
    ```

## 分组
可以用小括号指定一个子表达式.


- 可以分组批次处理

    ```python
    import re
    re.search('a{4}', '1aaaa1')  # match 匹配4个a
    re.search('(aa){2}', '1aaaa1')  # match 两个a为1组, 匹配2组
    re.search('(a{2}){2}', '1aaaa1')  # match 两个a为1组, 匹配2组
    ```

- 分组可以引用

    默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。后向引用用于重复搜索前面某个分组匹配的文本。

    ```python
    import re
    re.search('(aa)\\1', '1aaaa1')  # 两个a为1组, 第2组是用`\1`来替代, 匹配2组. 因为`\`首先会被python解释器转义一次, 送给regex的时候只有一个`\`了, 或者使用raw string
    match =  re.search(r'(aa)\1', '1aaaa1')  # 两个a为1组, 第2组是用`\1`来替代, 匹配2组
    match.group(0)  # 'aaaa' 0表示全部的匹配
    match.group(1)  # 'aa' 1表示第1组
    match.group(2)  # 2表示第2组, 这里因为第二组和第一组相同, 所以没有
    match.groups()  # ('aa',) 元组的行驶返回所有组, 这里因为第二组和第一组相同, 所以只有1个元素
    match.start()  # 1, 整体匹配的开始, 默认参数是0
    match.end()  # 5, 整体匹配的结束, 默认参数是0
    match.start(1)  # 1, 第1组匹配的开始
    match.end(1)  # 3, 第1组匹配的结束
    match.span()  # 将分组的匹配的起点和终点一起返回[start, end]
    ```

    可以给分组起个名字, 来引用

    ```python
    import re
    m = re.search('(\w+),(\w+),(\w+)', 'foo,quux,baz')
    m.groups()
    m.group(1)  # 'foo'
    m.group(3)  # 'baz'
    m.group(1, 2, 3)  # ('foo', 'quux', 'baz')

    m = re.search('(?P<w1>\w+),(?P<w2>\w+),(?P<w3>\w+)', 'foo,quux,baz')
    m.groups()  # ('foo', 'quux', 'baz')
    m.group('w1')  # 'foo'
    m.group('w3')  # 'baz'
    m.group('w1', 'w2', 'w3')  # ('foo', 'quux', 'baz')
    ```


## 零宽断言


- Lookahead

    `(?=<lookahead_regex>)`

    ```python
    re.search('foo(?=[a-z])', 'foobar')  # foo `(?=[a-z]) `表示foo后面必须跟[a-z]字母才满足要求, 然后返回foo
    re.search('foo(?=[a-z])', 'foo123')  # None
    re.search('foo([a-z])', 'foobar')  # foob
    ```

    `(?!<lookahead_regex>)`取反

    ```python
    re.search('foo(?=[a-z])', 'foobar')  # foo
    re.search('foo(?![a-z])', 'foobar')  # None
    re.search('foo(?=[a-z])', 'foo123')  # None
    re.search('foo(?![a-z])', 'foo123')  # foo
    ```

- lookbehind

    ```python
    re.search('(?<=foo)bar', 'foobar')  # bar
    re.search('(?<=qux)bar', 'foobar')  # None
    ```

    `(?<!<lookbehind_regex>)`取反

    ```python
    re.search('(?<!foo)bar', 'foobar')  # None
    re.search('(?<!qux)bar', 'foobar')  # bar
    ```



## 转义字符
将在正则里有特殊意义的字符, 转换为普通字符.

```python
import re
re.search('.', 'foo.bar')  # f , 这里`.`是通配符(wildcard)
re.search('\.', 'foo.bar')  # . , 这里`.`就是普通的字符
```

注意`\`本身就是一个特殊字符, 不能使用`\`来转义`\`, 因为python解释器会对`\`进行一次转义, 然后正则表达式会对它进行一次转义.

1. python首先对`\\`进行转义, 变成了一个`\`
2. regex仅仅收到了一个`\`, 因为后面没有跟转义的字符, 所以会报错

这时需要多加两个`\\`变为`\\\\`, 或者使用让正则表达式使用`raw string`, 也就是告诉python解释器, 不要转义, 直接传给regex. 建议在进行regex操作时, 都使用`raw string`来处理`\`.

```python
re.search('\\', r'foo\bar') # 错误
re.search('\\\\', r'foo\bar')  
re.search(r'\\', r'foo\bar')  
```

注意:只有在正则字符有特殊含义时, 才需要进行转义:
```python

re.search('{1}','foo{1}') # re.error: nothing to repeat at position 0 `{1}`已经有了正则含义
re.search('\{1}','foo{1}') # {1}, 对第一个`{`进行转义之后, `{1}`就变成了普通字符
```

更多的正则的转义字符:

- `\.`
- `\^`
- `\$`
- `\*`
- `\+`
- `\?`
- `\|`
- `\{}`
- `\[]`


## raw_string

在正则表达式中, 定义了一些可以赋予特殊含义的转义字符如:

1. `\w`表示字符
2. `\s`表示空白
3. `\d`表示数字
4. `\b`表示单词的开始和结束
5. `\1`表示分组

其中1,2,3使用普通字符串就可以表示, 但是4,5中的`\b`和`\1`在字符串中有特殊含义, 会先被python解释器转义.这时就需要使用到`raw string`或者给`\`前加`\`进行转义, 既`\\b`和`\\1`

```python
re.search('\w', 'abc') # a
re.search(r'\w', 'abc') # a
re.search('\s', 'a b') # 空
re.search(r'\s', 'a b') # 空
re.search('\d', '123') # 1
re.search(r'\d', '123') # 1
re.search('\bfoo\b', 'bar.foo') # None `\b`被转义成了'\x08'所以无法正常匹配
re.search(r'\bfoo\b', 'bar.foo') # foo , 另一种解法`re.search('\\bfoo\\b','bar.foo')`
re.search('(a)\1','aa') # None `\1`被转义成了`\x01`所以正则无法匹配
re.search(r'(a)\1','aa') # aa, 另一种解法`re.search(r'(a)\\1','aa')`
```

**建议在regex中如果遇到了`\`就使用raw string, 或者无脑对所有字符串都使用raw string, 因为不转义的string和raw string也是一样的.**

一个小问题, 看是不是能真正理解字符串的转义:
```python
re.search('\\\167', 'abc') # a 等价re.search('\w', 'abc'), 因为`\\`被python解释器转义为`\`, 而`\167`是ascii码`w`八进制表示, 下面的同理:
re.search('\\\163', 'a b') # 空
re.search('\\\144', '123') # 1
re.search('\\\142foo\\\142', 'bar.foo') # foo
re.search('(a)\\\61','aa') # aa
```

## 模式(flag)
在正则表达式之前加上`(?<flags>)`可以设置不同模式, 比如多行, 忽略大小写等

Letter|写法|re简写|re全称
--|--|--|--
a|`(?a)`|re.A|re.ASCII
i|`(?i)`|re.I|re.IGNORECASE
L|`(?L)`|re.L|re.LOCALE
m|`(?m)`|re.M|re.MULTILINE
s|`(?s)`|re.S|re.DOTALL
u|`(?u)`|re.U|re.UNICODE
x|`(?x)`|re.X|re.VERBOSE



## python
python中的`re`模块.

### 匹配
```python
re.search() # 匹配到一个既结束, 返回match对象. 类似的有re.match(), 是从字符串的开头进行匹配, 相当于re.search("^...","string")
re.findall() # 匹配所有, 返回元素是字符串的列表. 类似的有re.finditer, 返回的是迭代器
```

### 其他
```python
re.sub() 替换
re.split() 切分
re.compile() 变异正则表达式, 可以进行复用
```


参考:
https://realpython.com/regex-python/
https://realpython.com/regex-python-part-2/
https://www.jb51.net/tools/zhengze.html